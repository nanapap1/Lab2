## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2401`

#### Выполнил: `Москвитин Марк Александрович`

#### Вариант: `17`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

Программа выполняет следующие действия:

1. Считывает с консоли число строк N . Затем для каждой строки вво- дит количество элементов Mi, затем элементы строки, формируя массив размером N строк разной длины. Затем считывает числа A и B.
2. Сортирует строки массива по убыванию количества чисел, находя- щихся в заданном диапазоне [A, B]. Если количества равны, сортирует по сумме чисел вне диапазона.
3. Находит и выводит номер строки с наибольшим числом элементов, равных среднему значению всех элементов массива.
4. Выводит элементы массива, располагая их в виде пирамиды, начиная с центра и расширяя строки влево и вправо.
5. Заменяет все числа в массиве на логарифм по основанию 2 от их модуля и выводит полученный массив.

Для ее успешной работы мы должны:
- Придумать алгоритм сортировки массива относительно убывания по количеству чисел в заданном пользователем промежутке. Сортировать будем самым простым методом: поэлементно циклами for.
- На этапе ввода массива рассчитать среднее значение всех элементов, а потом найти массив с наибольшим количеством элементов, равных ему. Точно также воспользуемся стандартными свойствами в виде прохождения всех элементов циклом for.
- Отсортировать массив по увеличению количества элементов в строчке,чтобы вывести его пирамидой. Также попробуем учитывать наличие десятичных и больших разрядов.
- Поэлементо, благодаря двойному циклу for, заменить элементы массива на значение их логарифма с основание 2. Ввиду отсутствия данной функции, вспомним теорему про деления логарифмов с общим основанием, чем и получим нужные нам значения, а затем просто выведем массив.


### 2. Входные и выходные данные

**Данные на вход**

По условии на вход нам подается два натуральных числа N,M, обозначающие количество строк в двумерном массиве и количество элементов в каждой строке, а также два целых числа A и B, представляющие собой границы диапазона, нужного для сортировки массива. 

|    Число    | Тип                | min значение    | max значение   |
|-------------|--------------------|-----------------|----------------|
|     N       |  Натуральное число |        1        |    +Infinity   |
|     M       |  Натуральное число |        1        |    +Infinity   |
|     A       |    Целое число     |    -Infinity    |    +Infinity   |
|     B       |    Целое число     |    -Infinity    |    +Infinity   |

**Данные на выход**

На выход представляется несколько данных:
- Номер строки с наибольшим числом элементов, равных среднему значению всех элементов массива;
- Элементы массива для их вывода пирамидкой;
- Отсортированный по количеству числе в диапазоне массив, в котором все числа заменены на значение их логарифма по основанию 2.

|    Число        |          Тип          | min значение    | max значение   |
|-----------------|-----------------------|-----------------|----------------|
| num_cnt_srzhach | Неотрицательное число |        0        |    +Infinity   |
|     b[i][j]     | Целое число, элемент  |    -Infinity    |    +Infinity   |
|     a[i][j]     | Целое число, элемент  |    -Infinity    |    +Infinity   |


### 3. Выбор структуры данных

Нам придется работать с целыми и натуральными числами, поэтому для их хранения воспользуемся переменными типа integer. Получается, нам потребуется и соответствующий тип массивов.

|                |    Тип (в Java)    |  min значение   |  max значение  |  Название переменной  |
|----------------|--------------------|-----------------|----------------|-----------------------|
|       N        |      Integer       |        1        |   2147483647   |           N           |
|       M        |      Integer       |        1        |   2147483647   |           M           |
| Главный массив |     Integer[][]    |       [][]      |     [N][M]     |           a           |
| Массив для п3  |     Integer[][]    |       [][]      |     [N][M]     |           b           |
| Сумма эл. масс.|      Integer       |   -2147483648   |   2147483647   |        sum_all        |
|Кол-во эл. масс.|      Integer       |   -2147483648   |   2147483647   |      cnt_elements     |
|Наибольшая длина|      Integer       |   -2147483648   |   2147483647   |         max_M         |
|Счетчик цикл №1 |      Integer       |   -2147483648   |   2147483647   |           i           |
|Счетчик цикл №2 |      Integer       |   -2147483648   |   2147483647   |           j           |
|Счетчик цикл №3 |      Integer       |   -2147483648   |   2147483647   |           k           |
|  Cр. значение  |      Integer       |   -2147483648   |   2147483647   |        sr_zhach       |
|  Макс. кол-во  |      Integer       |   -2147483648   |   2147483647   |          max          | 
|Кол-во элементов|      Integer       |   -2147483648   |   2147483647   |          cnt          |
| Номер строчки  |      Integer       |   -2147483648   |   2147483647   |          num          |
| Сумма диапаз.  |      Integer       |   -2147483648   |   2147483647   |          sum1         |
| Сумма диапаз.  |      Integer       |   -2147483648   |   2147483647   |          sum2         |
|Масс.для перест.|      Integer[]     |        []       |  [a[k].length] |           d           |
|Кол-во cр. знач.|      Integer       |   -2147483648   |   2147483647   |      cnt_srzhach      |
|Макс. кол-во ср.|      Integer       |   -2147483648   |   2147483647   |     max_cnt_srzhach   |
| Номер строчки  |      Integer       |   -2147483648   |   2147483647   |     num_cnt_srzhach   |
|Макс. кол-во дл.|      Integer       |   -2147483648   |   2147483647   |       max_length      |
| Номер строчки  |      Integer       |   -2147483648   |   2147483647   |       num_length      |
|Кол-во особ. эл.|      Integer       |   -2147483648   |   2147483647   |       cnt_length      |
|Кол-во особ. эл.|      Integer       |   -2147483648   |   2147483647   |       cnt_length1     |
|Кол-во особ. эл.|      Integer       |   -2147483648   |   2147483647   |           das         |
|Проверк для пир.|      Boolean       |        -        |        -       |           dss         |


### 4. Алгоритм
**Алгоритм работы программы**
1. Получаем на вход и считываем переменную **N**, выраженную натуральным числом и показывающую количества строчек в двумерном массиве. Благодаря этому значению инициализируем два массива, которые понадобятся нам для сортировки.
2. Получаем на вход и считываем переменную **M** для каждой строчки, что способствует возможности построчного ввода элементов массива. Заполняем два массива одинаково, параллельно считая сумму значений, их количество для определения среднего арифметического, а также определяем строчку с наибольшим количеством элементов для дальнейшего создания пирамиды.
3. Получаем на вход и считываем переменную **A,B**, которые представляют нужный диапазон для первой сортировки по убыванию.
4. Пробегая каждый раз последние k элементов массива, где k от a.length до 2, мы определяем среди них наибольший, и ставим его в началу пробегаемого куска строчки. Наибольший определяем в соответствии с условием - количество чисел в диапазоне. Запоминаем сумму вне диапазона, чтобы применить на случай совпадения количества чисел в диапазоне. Если необходимо, определяем наибольший через сумму.
5. Проверяем поэлементно строчки массива на количество значений, совпадающих со средним значением всех элементов массива. Выводим номер соответствующей строчки.
6. Сортируем по возрастанию запасной массив b относительно количества элементов в списках, чтобы использовать для построения пирамиды. Используем классический способ перестановок с третьей переменной. Построчно выводим пробелы и значения, чтобы построить конструкцию пирамиды. Проверяем на предмет кардинальной разницы в разрядах строчек.
7. Поэлементно заменяем элементы в оригинальном массиве на их значения логарифма с основанием два. В случае наличия 0 среди элементов выводим соответствующее информационное сообщение на экран. Выводим получившееся значение на экран.

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class main {
  public static Scanner in = new Scanner(System.in);  // Объявляем объект класса Scanner для ввода данных
  public static PrintStream out = System.out;  // Объявляем объект класса PrintStream для вывода данных
  public static void main(String[] args) {
   int N = in.nextInt();//ввод N

   int[][] a = new int[N][];
   int[][] b = new int[N][];  //инициализируем массивы
   
   int sum_all = 0;
   int cnt_elements = 0;
   int max_M=0; //объявляем переменные
   for (int i = 0 ; i < a.length ; i++) {
      int M = in.nextInt();  //получаем размеры строчек в массивах
      a[i] = new int[M];
      b[i] = new int[M];
      cnt_elements = cnt_elements + M; //считаем общее количество элементов для ср. значения
      for (int j = 0 ; j < a[i].length ; j++) {
         a[i][j] = in.nextInt(); 
         b[i][j] = a[i][j]; //заполняем основной и запасной массив;
         sum_all = sum_all + a[i][j];  //считаем сумму для среднего значения 
      }
      if (M > max_M) {
         max_M = M; //для пирамиды ищем большую длину
      }
   }
   int sr_zhach = sum_all / cnt_elements; //считаем среднее арифметическое

   int A = in.nextInt();
   int B = in.nextInt();  //вводим границы диапазона 
   int max =0;
   int cnt = 0;
   int num = -1;
   int sum1=0;
   int sum2 = 0; //объявляем нужные переменные
   for (int k=0;k<(a.length-1);k++) {
      max = 0;
      sum2 =-1;
      num = 0;
      for (int i = 0+k; i < a.length; i++) {
         cnt = 0; //обнуляем переменные для новой итерации 
         for (int j = 0 ; j < a[i].length ; j++) {
            if (a[i][j] >= A && a[i][j] <=B) {
               cnt++; //считаем кол-во элементов из диапазона в строчке
            }
         }
         if (cnt > max) { //сравниваем полученное количество с нынешним минимальным
            max = cnt;
            num = i;
            sum2= 0; //принимаем значения
            for (int j = 0 ; j < a[i].length ; j++) {
               if (a[i][j] < A && a[i][j]>B) {
                  sum2 =a[i][j] + sum2 ; //считаем сумму для равенства сравнения 
               }
            }
         } 
         else {
            if (cnt==max) {
               sum1 =0;
               for (int j = 0 ; j < a[i].length ; j++) {
                  if (a[i][j] < A || a[i][j]>B) {
                     sum1 =a[i][j] + sum1 ; //считаю сумму каждого кандидата в случае сравнения
                  }
               }
               if (sum1 >= sum2) { //сравниваем сумму, определяем наиболее подходящий элемент
                  sum2 = sum1;
                  num = i;
               }
            }
         }
      }
      int[] d = new int[a[k].length];
      d = a[k];
      a[k] = a[num];
      a[num] = d; //перестановка с третьим элементом
   }
   int cnt_srzhach = 0;
   int max_cnt_srzhach = 0;
   int num_cnt_srzhach = 0;  //объявляем переменные
   for (int i = 0 ; i < a.length ; i++) {
      cnt_srzhach = 0;  //обнуляем 
      for (int j = 0 ; j < a[i].length ; j++) {
        if (a[i][j] == sr_zhach) {
          cnt_srzhach++; //ищем количество элементов в строчке, совпадающих по значению со средним арифметическим
        } 
      }

      if (cnt_srzhach > max_cnt_srzhach) { //сравниваем, не больше ли оно нынешнего максимума
         max_cnt_srzhach = cnt_srzhach; 
         num_cnt_srzhach = i;
      }
   }
   out.println("Номер наибольшой строки: " + (num_cnt_srzhach+1));   //выводим номер наибольшей
   int max_length = 0;
   int num_lenght =-1;
   int max1 = 0;  //объявляем переменные 
   for (int k=b.length-1;k>=0;k--) { // сортируем запасной массив по кол ву элементов 
      max_length = 0;
      num_lenght = -1;
      for (int i = 0; i <= k; i++) {
         if (b[i].length > max_length) {  //сравниваем с нынешним максимумом
            max_length = b[i].length;
            num_lenght = i;
            max = 0;
            for (int j = 0; j <b[i].length; j++) {
               if (b[i][j] > max) { //смотрим макс. элемент, чтобы сравнить строчки в случае равенства элементов
                  max = b[i][j];
               }
            }
         } 
         else {
            if (b[i].length == max_length) { //сравниваем максимальные элементы в случае равенства
               max1 = 0;
               for (int j = 0; j <b[i].length; j++) {
                  if (b[i][j] > max1) {
                     max1 = b[i][j];  //ищем максимальный в новом кандидате
                  }
               }
               if (max1 > max) {
               max_length = b[i].length;
               num_lenght = i;
               }
            } 
         }
      }
      int[] d = new int[b[k].length];
      d = b[k];
      b[k] = b[num_lenght];
      b[num_lenght] = d; //делаем перестановку в начало
   }
   boolean dss = true;
   int das = -2312312;
   int cnt_lenght =0; 
   int cnt_lenght1 =0; //объявляем переменные
   for (int j = 0 ; j < b[0].length ; j++) {
      N = b[0][j];
      while (N >10) {
         cnt_lenght1++;
         N = N / 10; //считаем разряды для первой строчки
     }
   }
   for (int i =1; i <b.length;i++ ) { 
      cnt_lenght =0;
      for (int j = 0 ; j < b[i].length ; j++) {
         N = b[i][j];
         while (N >10) {
            cnt_lenght++;
            N = N / 10; //считаем разряды
        }
      }
      for (int p = 0; p < 1000; p++) {
      if ((b[i].length * p == b[i -1].length && cnt_lenght * p !=cnt_lenght1) || (b[i].length  == b[i -1].length*p && cnt_lenght* p !=cnt_lenght1* p)) { //сравниваем разряды для построения пирамиды, чтобы знать, нужно ли нам учитывать разницу в разрядах
         dss = false;
         cnt_lenght1 = cnt_lenght;
         break;
      }
   }
      
   }
   for (int i =0; i <b.length;i++ ) {
      for (int j = 0 ; j < b[i].length ; j++) {
         N = b[i][j];
         cnt_lenght =0;
         while (N >10) {
             cnt_lenght++;
             N = N / 10; //считаем разряды опять
         }
         if (cnt_lenght != das && das !=-2312312 && dss != false) {  // провеярем построчно
            dss = false;
            
            
            break; 
         }
         
         cnt_lenght = das;
      }
   }
   if (dss) {  
  for (int i =0; i <b.length;i++ ) {
      
      
      for(int ds = 0; ds < (max_M - b[i].length);ds++) {
          out.print(" "); //выставляем нужное количество элементов в зависимости от недостатка элементов до максимума
      }
      for (int j =0; j < b[i].length;j++ ) {
          out.print(b[i][j] + " "); //выводим сами элементы
      }
   
      
      out.println();
    }

   }
   else { //аналогично если проверки нету, просто учитываем разницу в разрядах 
      for (int i =0; i <b.length;i++ ) {
      
         cnt_lenght =0;
      for (int j =0; j < b[i].length;j++ ) {
          N = b[i][j];
          while (N >10) {
              cnt_lenght++;
              N = N / 10; //считаем опять разряды
          }
       }
         for(int ds = 0; ds < (max_M - b[i].length)-cnt_lenght;ds++) {
             out.print(" "); //выставляем нужное количество элементов в зависимости от недостатка элементов до максимума
         }
         for (int j =0; j < b[i].length;j++ ) {
             out.print(b[i][j] + " "); //выводим сами элементы
         }
      
         
         out.println(); //перенос на новую строчку
       }
      
   }
   for (int i =0; i <a.length;i++ )
 {
   for (int j =0; j < a[i].length;j++ ) {
    if (a[i][j] != 0) {
      a[i][j] = (int)(Math.log(Math.abs(a[i][j])) / Math.log(2)); //высчитываем логарифмы в соответствии с теоремой из-за отсутствия нужной функции
    }
    else {
      out.println("Логарифм нуля не определен, поэтому вместо него будет выведен нуль"); //нельзя логарифм от нуля
    }
 }
 }
 for (int i =0; i <a.length;i++ )
 {
   for (int j =0; j < a[i].length;j++ ) {
      out.print(a[i][j] + " "); //выводим массив
 }
 out.println(); //перенос на новую строчку
 }
}
}
 ``` 

### 6. Анализ правильности решения
Программа работает корректно при подстановке всевозможных различных значений.
1. Одинаковое количество элементов.
    - **Input**:
        ```
        3
        7
        1 2 3 4 7 9 10
        7
        1 5 6 7 8 9 10
        7 
        1 2 3 4 5 10 11
        5
        9
        ```
    - **Output**:
        ```
        Номер наибольшой строки: 1
        1 5 6 7 8 9 10 
        1 2 3 4 7 9 10 
        1 2 3 4 5 10 11 
        0 2 2 2 3 3 3 
        0 1 1 2 2 3 3 
        0 1 1 2 2 3 3 
        ```
2. Одинаковое количество элементов в диапазоне (нулевое).
    - **Input**:
        ```
        3
        7
        0 0 0 0 0 0 0
        7  
        1 1 1 1 1 1 1
        7 
        2 2 2 2 2 2 2 
        5
        9
        ```
    - **Output**:
        ```
        Номер наибольшой строки: 3
        0 0 0 0 0 0 0 
        1 1 1 1 1 1 1 
        2 2 2 2 2 2 2 
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        1 1 1 1 1 1 1 
        0 0 0 0 0 0 0 
        0 0 0 0 0 0 0
        ```
3. Разные элементы.
    - **Input**:
        ```
        5
        6
        1 2 3 4 7 10
        8
        1 2 5 6 7 8 9 10
        9
        0 0 0 0 0 0 0 0 0
        6
        1 1 1 -1 1 1
        7 
        1 2 3 4 5 10
        5
        9
        ```
    - **Output**:
        ```
        Номер наибольшой строки: 2
          1 1 1 -1 1 1 
          1 2 3 4 7 10 
          1 2 3 4 5 10 
        1 2 5 6 7 8 9 10 
        0 0 0 0 0 0 0 0 0 
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        Логарифм нуля не определен, поэтому вместо него будет выведен нуль
        0 1 2 2 2 3 3 3 
        0 1 1 2 2 3 3 
        0 1 1 2 2 3 
        0 0 0 0 0 0 0 0 0 
        0 0 0 0 0 0
        ```
4. Проверка пирамиды (один разряд).
    - **Input**:
        ```
        3
        3
        1 2 3
        5
        1 2 2 2 3
        2 
        1 3
        2 
        4
        ```
    - **Output**:
        ```
        Номер наибольшой строки: 1
          1 3 
          1 2 3 
        1 2 2 2 3 
        0 1 1 1 1 
        0 1 1 
        0 1 
        ```
5. Проверка пирамиды (разные разряды).
    - **Input**:
        ```
        3
        3
        1 2 3
        2 
        10 11
        1
        1
        2 
        4
        ```
    - **Output**:
        ```
        Номер наибольшой строки: 1
            1 
          10 11 
          1 2 3 
          0 1 1 
          3 3 
          0 
        ```
6. Отрицательные элементы.
    - **Input**:
        ```
        3
        3
        -1 -2 -3
        2 
        -10 -11
        1
        -1
        2 
        4
        ```
    - **Output**:
        ```
        Номер наибольшой строки: 1
          -1 
        -10 -11 
        -1 -2 -3 
        0 
        0 1 1 
        3 3 
        ```
7. Отрицательные элементы, ч2.
    - **Input**:
        ```
        3
        3
        -1 -2 -3
        2 
        -10 -11
        1
        -1
        -4 
        -2
        ```
    - **Output**:
        ```
        Номер наибольшой строки: 1
          -1 
        -10 -11 
        -1 -2 -3 
        0 1 1 
        0 
        3 3 
        ```
  

